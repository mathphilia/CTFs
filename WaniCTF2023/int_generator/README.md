# int\_generator
category: Misc  
282 points, 37 solves

## 問題
> 0以上2**35以下の好きな整数を入れると16桁の整数になって返ってくる機械があります。  
> flag1, flag2, flag3はそれぞれ何でしょう？  
> 
> FLAG format：FLAG{flag1\_flag2\_flag3}

## 解法
この問題は個人的にはあまりよろしくない問題だと思った。まず、chall.pyに`print("int_generator(num1):{}".format(int_generator(num1)))`と書いてあるのにoutput.txtでは`int_generator(flag1):1008844668800884`となっている。また、`num1 = random.randint(0, 2 ** (k - 1))`と書かれているにもかかわらず`num1`, `num2`, `num3`は明らかに作為的な値(後述する)になっている。愚痴はここまでにして、解法の説明に入る。  
chall.pyにおいて最重要なのは`pad`函数の中のfor文である。`minus`がTrueかFalseかで挙動が変わり、端的に言えば`minus`がTrueなら最終的な返り値の値は奇数に、Falseなら偶数になる。今回の出力はすべて偶数なので、`minus`はFalseであったことになる。また、`minus`がFlaseの場合このfor文の部分で施されるパディングは`008844668800884466880088446688…`というような周期的な形になる。出力を見ると

> int\_generator(flag1):1**008844668800884**  
> int\_generator(flag2):226466343**0088446**  
> int\_generator(flag3):67728140784**00884**  

というように、下線部がパディングの形になっていることが分かる(一行目は`00`が二か所あるので、後半からパディングが始まっている可能性がないと即断はできないが)。  
`flag1`を復元してみよう。`minus`がFalseのとき、`pad`函数はざっくり言えば`cnt`,`x`,パディングを並べた数を返す(`x`は`int_generator`の引数ではなく`pad`函数の引数を指している)。例えば`cnt`が3で`x`が4974038784でパディングが00884なら出力は3497403878400884になる。今回パディングは008844668800884か00884である。前者の場合`cnt`と`x`を並べたものが1ということになるが、この処理における「並べる」というのが文字列的に並べるのではなく数値的に処理されているので、`cnt`と`x`の一方が$04でもう一方が$1$であればよい。この条件を満たすのは`flag1`が0のときである。後者のパターン(パディングが00884)はあり得ないので(証明略)、`flag1`は0と分かる。  
次に`flag2`を調べる。`int_generator`の引数が0でない場合、`minus`がFalseになるためには`int_generator`のwhileループに入らなければならない。したがって最初の`f`の返り値が正である必要がある。したがって`flag2`は平方すると$2^{36}$になる数、つまり$2^{18}$の倍数であると分かる。`cnt`は`f`が適用された回数であり、`cnt`-1回目(1-based)の適用結果が(`pad`函数の引数の)`x`である。つまり`cnt`と`x`の組の候補としては$(2,26466343),(22,6466343)$などがある。`cnt`が$2$の場合、`f(flag2)`即ち`flag2-flag2**2/2**36`が$26466343$になる。二次方程式を解いてもよいが、このくらいなら`flag2`≒$26466343$であることを使った方が速い。見たところ$101\times2^{18}$に近そうなので計算してみるとビンゴ。`cnt`が$22$や$226$であることはあり得ないので(証明略)、`flag2`は$101\times2^{18}=26476544$である。  
`flag3`も`flag2`と同様にすればよいが、`f`(x)=hogeの解を直感で$6$回も見つけるのは大変なので(x≒hogeも精度が悪いし)、Walfram|Alpha辺りに二次方程式を解いてもらう。解の候補が複数出ることもあるが、$6$回の連続で整数解が出るルートは$1$つだけ。`flag3`は$34359738368(=2^{35})$である。  
`num1`, `num2`, `num3`の値が作為的であるといった意味が分かっていただけただろうか。なお、前述のとおり出力が偶数になるのは入力が$2^{18}$の倍数のときだけであり、入力の範囲は$0$以上$2^{35}$以下なので、この時点で解の候補は$(1+2^{17})$個しかない。よって何も考えず全探索するのが一番速かったりする。solver.pyではこの方法を使った。
